---
title: "Introduction to Transparent Bayesian Data Analysis (chi22-course)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: Abhraneel Sarma and Fumeng Yang
output: 
  html_document: 
    highlight: pygments
    toc: yes
    df_print: kable
---

```{=html}
<style>
.sourceCode.r{
  background-color:#f7f8f9ff;
  font-family: Courier New;
  font-weight: bold
}

</style>
```
```{r knit-github, eval=FALSE,echo=FALSE,include=FALSE}
# compile for github, you can ignore this
library(rmarkdown)
render("bayesian-analysis.Rmd", md_document(variant = "gfm"), knit_root_dir = "/Users/fm/Documents/Github/CHI-Course-Transparent-Quant")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
rm(list = ls(all.names = TRUE)) 

library(dplyr)
library(tibble)
library(purrr)
library(ggpubr)
library(tidyr)
library(forcats)
library(gtools)

library(broom)
library(broom.mixed)

library(modelr)

library(brms)
library(tidybayes)

library(ggdist)
library(bayesplot)
library(ggplot2)
library(knitr)

# set up the global theme
theme_set(theme_ggdist() + 
          theme(strip.background = element_blank(),
               plot.title = element_text(hjust = .5)))

set.seed(99) 

BRM_BACKEND <- ifelse(require("cmdstanr"), 'cmdstanr', 'rstan')

DARK_PURPLE <- '#351c75'
GOLD_COLOR <- '#8f5902'

COLOR_PALETTE <- c(DARK_PURPLE, GOLD_COLOR)
```

# Introduction

In this document, we will outline the Bayesian analogs of the statistical analyses described in lecture 1 ([Github code](https://github.com/chatchavan/CHI-Course-Transparent-Quant-Lecture-1)).

## Note on MathJax

If you use RStudio's Visual editor mode. Check if you can see anything written in the following parenthesis: ($k$). If not, your RStudio has a bug. This problem will be fixed in future versions. Meanwhile, if some text seems to be missing in the file below, simply position your cursor around the missing area to reveal the underlying code.

## Helper function

The following function extracts results from different models and generate results of the same format to be used in visualizations

```{r helper}
tidy.wrapper = function(model) {
  if (class(model) == "lm") {
    tidy(model, conf.int = TRUE) %>%
      select(-c(statistic, p.value)) %>%
      mutate(model = "Frequentist") %>%
      select(model, everything())
  } else if (class(model) == "brmsfit") {
    tidy(model) %>%
      filter(effect == "fixed") %>%
      select(c(term:conf.high)) %>%
      mutate(model = "Bayesian") %>%
      select(model, everything())
  } else {
    stop("unknown model class")
  }
}
```

# Dataset 1

Let's first load and take a look at the data in a table:

```{r load-dataset, warning=FALSE, message=FALSE}
dataset = readr::read_csv("data/blinded.csv", col_types = "dcd")

head(dataset)
```

Recall from the previous lecture that this dataset contains results from four experiments. In each experiment, participants are placed in either a *graph* or *no graph* condition, and asked to rate the effectiveness of the intervention on a 9-point Likert-style question. Here, we plot the data to show the distribution of these responses:

```{r plot-dataset, fig.height = 3, fig.width = 7}
dataset %>% 
  mutate(effectiveness = fct_rev(factor(effectiveness, levels = 1:9)),
         experiment = as.factor(experiment)) %>%
  
  # stacked bar plot
  ggplot(aes(x = condition, fill = effectiveness)) +
  geom_bar(position = "stack", stat="count") +
  
  # plot data for different experiments as small multiples
  facet_wrap(. ~ experiment) +
  
  # grey color scale is robust for colorblind
  scale_fill_brewer(palette="Purples", drop = FALSE) +
  
  # horizontal plot
  coord_flip() +
  
  # legend
  guides(fill = guide_legend(reverse = TRUE)) 
```

For the purposes of this lecture, we will focus on the first experiment.

```{r filter-data}
exp1.data = dataset %>%
  filter(experiment == 1)

head(exp1.data)
```

## Model 1. Wilcoxon signed rank test

The first model discussed in the previous lecture was the `Wilcoxon signed rank test`. This is a non-parametric test which we will skip for now. Although, there exists Bayesian non-parametric methods, they are too advanced for this lecture.

## Model 2. Student's *t*-test

The second model discussed was the *t*-test. Although R contains a function (`t.test`) to perform this analysis, the *t*-test is essentially a linear regression, and thus can be performed using the linear model function in R (`lm`). The following code shows the equivalent linear-model for a paired sample *t*-test:

### Frequentist t-test

```{r dataset1-lm}
dataset1.lm.freqt <-
  lm(
    effectiveness ~ condition - 1, # we remove intercept
    data = exp1.data
  )
```

### Step 1: Build the model (likelihood)

Before we implement a Bayesian model, let us take a look at the distribution of responses. Although we know that we are going to use a *t* distribution, we still plot the data to set how it looks like. Usually, this will help us decide our likelihood function.

```{r dataset1-distribution}
  exp1.data %>%
     ggplot(., aes(x = effectiveness)) +
  geom_histogram(fill = DARK_PURPLE, color = NA, binwidth = 0.5, center = 0) +
  scale_x_continuous(breaks = seq(0, 10, by = 1))
```

We can see from the above plot that the responses are discrete. This is important to keep in mind when specifying a Bayesian model.

Let's also look how a Student's *t* distribution varies different parameter. Mu is location, sigma is dispersion (which is simiilar to the standard deviation parameter of the Gaussian distribution), and nu (df) control the tail.

```{r draw-student-t, fig.height=4, fig.width=8}
ggplot() +  xlim(-10, 10) +
  geom_function(
    color = "black",
    fun = function(x)
      dstudent_t(x, mu = 0, sigma = 1, df = 5) ,
    size = 1
  ) +
  geom_function(
    color = "gray80",
    fun = function(x)
      dstudent_t(x, mu = 0, sigma = 1, df = 50),
    size = 1
  ) +
  geom_function(
    color = "gray60",
    fun = function(x)
      dstudent_t(x, mu = 0, sigma = 4, df = 5),
    size = 1
  ) +
  geom_function(
    color = "gray40",
    fun = function(x)
      dstudent_t(x, mu = 2,  sigma = 1, df = 5),
    size = 1
  ) +
  xlab("x")

```

Next, we will implement the Bayesian analog of the linear model described earlier. Here's what the model formula will look like when implemented using the `bf()` function from the `brm` package:

```{r dataset1-bayesian-t-test-formula}
dataset1.brm.bayesiant.formula <- bf(effectiveness ~ condition - 1,
                                     family = student())
```

Let us take a minute to understand this code. It says that we are regressing the variable `condition` on `effectiveness`. The `- 1` removes the intercept term. The family argument is used to specify the probability distribution of the likelihood --- in other words, what is the distribution of $P(y)$.

### Step 1: Build the model (priors)

The blank ones are flat (uniform) priors. These are improper priors and usually needed to be set. We can and should adjust the priors given by `brm`.

```{r dataset1-bayesian-t-test-get-prior}
as_tibble(get_prior(dataset1.brm.bayesiant.formula, data = exp1.data))
```

Next, we need to specify priors for the parameters in the model. We will discuss briefly how these prior distributions were obtained.

For the prior on `b` which is the mean parameter of the Student's *t* distribution (used as the likelihood), an unbiased assumption would be that they should be centered around 5 (which is the center of the 9 possible answers), and the mean would likely be greater than 1 and less than 9 (unless every single participant responded either 1 or 9; but we know that was not the case).

The prior on `sigma` determines the dispersion parameter of the Student's *t* distribution. Now, considering that our data is bounded between 1 and 9, a uniform distribution will have the maximum variance given these constraints. The variance of such an uniform distribution would be: `sd(runif(1e4, 1, 9)` which is approximately 2.5. We know that our data will most likely have less variance than such a uniform distribution. Thus, we want the prior on `sigma` to assign very little probability mass for values greater than 2.5. Our prior `student_t(3, 0, 1)` assigns less than 0.05 probability to values greater than 2.5 (you can check by running the following code in the console: `sum(gamlss.dist::rTF(1e4, 0, 1, 3) > 2.5) / 1e4`).

```{r dataset1-bayesian-t-test-priors}
dataset1.brm.bayesiant.priors = c(
      prior(normal(5, 1.5), class = "b"),
      prior(student_t(3, 0, 1), class = "sigma")
  )
```

### Step 1: Build the model (prior predictive checks)

Before we implement the regression model, it is advisable to perform some prior predictive checks. Bayesian models are generative. In other words, it is possible to sample values from the prior distributions, feed them through the likelihood function to obtain a *prior predictive* distribution.

The prior predictive distribution should ideally resemble the data generating process, and should not assign probability mass to unlikely or impossible values. If the prior predictive distribution is assigning substantial probability mass to unlikely or impossible values, we should adjust our choice of prior distributions. Prior predictive checks also help make explicit some of the assumptions that go into the prior specification process.

Another important thing to note is that `brms` often specifies improper priors (denoted by `flat`) by default. If the priors are improper, we cannot sample draws from the prior predictive distribution.

The following code block implements some prior predictive checks:

```{r}
tibble(
  x = seq(0, 10, by = 0.01),
  y = dnorm(x, 5, 1.5)
) %>%
  ggplot(aes(x, y)) +
  geom_line(color = "#b8925f", size = 2) +
  scale_x_continuous(breaks = seq(1, 9, by = 1)) +
  labs(y = "Density") +
  theme(
    panel.grid.major.y = element_line(),
    axis.title.y = element_text(angle = 90, size = 24),
    axis.text = element_text(size = 20)
  )
```


```{r dataset1-bayesian-t-test-run-prior-predictive-check, fig.height=4, fig.width=9}
dataset1.brm.bayesiant.priorchecks <-
  brm(
    dataset1.brm.bayesiant.formula,
    prior = dataset1.brm.bayesiant.priors,
    data = exp1.data,
    backend = BRM_BACKEND,
    sample_prior = "only",
    file = "rds/dataset1.brm.bayesiant.priorchecks.rds"
  )

n_prior_draws <- 30

# extract n = 100 draws from the prior predictive distribution
dataset1.bayesiant.yprior <-
  posterior_predict(dataset1.brm.bayesiant.priorchecks, ndraws = n_prior_draws)

# the following computes the probability density for each "draw"
dataset1.bayesiant.ppc <- 
  dataset1.bayesiant.yprior %>%
  as_tibble() %>%
  mutate(.draw = row_number()) %>%
  pivot_longer(
    cols = starts_with("V"),
    names_to = "participant",
    names_prefix = "V",
    values_to = ".value"
  ) %>%
  group_by(.draw) %>%
  summarise(.value = list(.value)) %>%
  mutate(dens.x = map(.value, ~ density(.)$x),
         dens.y = map(.value, ~ density(.)$y))

dataset1.bayesiant.ppc %>%
  select(-.value) %>%
  unnest(c(dens.x, dens.y)) %>%
  ggplot() +
  geom_line(
    aes(x = dens.x, y = dens.y, group = .draw),
    color = DARK_PURPLE,
    alpha = .5,
    size = .75
  ) +
  labs(y = "", x = 'Draws from the prior predictive distribution')

# flat it
dim(dataset1.bayesiant.yprior) <- n_prior_draws * 123

# create a new table and assign .draw number
tibble(.value = dataset1.bayesiant.yprior,
       .draw = rep(1:n_prior_draws, times = 123)) %>%
  ggplot() +
  geom_density(
    aes(x = .value, group = .draw),
    color = DARK_PURPLE,
    alpha = .5,
    size = .5
  ) +
  labs(y = "", x = 'Draws from the prior predictive distribution')
```

Although, based on the above plot, it seems like the model is assigning some non-zero probability to impossible values (less than 1 or more than 9), these are primarily a result of our choice of the likelihood function --- the `student_t()` distribution does not allow us to set bounds on the predictive distribution. Another reason for extreme values may be the use of a Student's *t* prior for sigma with 3 degrees of freedom --- this distribution has fat tails and thus might result in predicting large values for the standard deviation parameter in our model.

We will revisit this point later. For now, let's move forward, and fit the model.

### Step 2: Computing the posterior probability distribution

Next, we compute the posterior probability distribution using `brms` and `Stan`. Depending on the complexity of your model, this step may take a lot of time. Our model is not so complex, hence this will not take too long :)

```{r dataset1-bayesian-t-test-run}
dataset1.brm.bayesiant =
  brm(
    dataset1.brm.bayesiant.formula,
    prior = dataset1.brm.bayesiant.priors,
    data = exp1.data,
    backend = BRM_BACKEND,
    # There are many other parameters you can play with.
    # Here we use default parameters to simplify the lecture.
    # We save the model in the following file.
    file = "rds/dataset1.brm.bayesiant.rds"
  )
```

### Step 3: Evaluate the fit

After the compilation step of the model is complete, we can evaluate the fit and examine the result. Similar to `lm()`, the first step is to call the `summary()` function on the variable which contains the model compilation result:

```{r dataset1-bayesian-t-summary}
summary(dataset1.brm.bayesiant)
```

This will give us an overview of the coefficients of the various parameters, along with the 95% credible intervals. This result shows that there is substantial overlap between the credible intervals for the two conditions. Before we delve deeper into the results, it is important to run some diagnostics on the sampling process.

### Step 3: Evaluate posterior predictions

First, we call `bayesplot` to draw posterior distributions and MCMC traces for each parameter. We want to check whether the four chairs have mixed well. If they have, this implies that the model has converged.

```{r dataset1-diagnotics-1}
color_scheme_set(scheme = "purple")
plot(dataset1.brm.bayesiant, newpage = T)
```

Next, we need to examine if the posterior distributions computed by our MCMC process resembles the data. Each draw from the posterior predictive distribution should roughly resemble a "hypothetical experiment" with the same experimental design. Thus, if our posterior predictive distribution looks very different from the data, it implies that something has gone awry in our model building step (Step 1).

They are many ways you can draw from the posterior predictive distribution. Here we use `posterior_predict` from `brms`.

```{r dataset1-posterior-diagnotics-2}
dataset1.bayesiant.y <- exp1.data$effectiveness

dataset1.bayesiant.yrep <-
  posterior_predict(dataset1.brm.bayesiant)

dataset1.bayesiant.yrepgroup <-
  posterior_predict(dataset1.brm.bayesiant, data.frame(condition = c('graph', 'no_graph')))

head(as_tibble(dataset1.bayesiant.yrep[,1:11]))
```

We use `bayesplot` to perform these diagnostic tests. First, we plot the first eight draws of posterior predictions and the original data. Again, there are many ways to do this (and these will be discussed in greater detail in Lecture 3).

```{r dataset1-posterior-diagnotics-3, fig.height=4, fig.width=10}
ppc_hist(y = dataset1.bayesiant.y,
         yrep = dataset1.bayesiant.yrep[1:8,],
         binwidth = .5)
```

An alternative approach would be to plot densities for each *draw* from the posterior predictive distribution superimposed with the density from the actual data:

```{r dataset1-posterior-diagnotics-4, fig.height=3, fig.width=10}
ppc_dens_overlay(y = dataset1.bayesiant.y,
                 yrep = dataset1.bayesiant.yrep[1:30,])
```

Finally, we look at whether our model is able to capture the summary statistics properly. Below we show the distribution of the estimated posterior mean for the two conditions, as well as the actual mean of the data in the two conditions. Since the actual mean appears to be centered around the estimated posterior distribution of the mean, we can conclude that it is roughly capturing the relevant information from the experimental data.

```{r dataset1-posterior-diagnotics-5, fig.height=3, fig.width=10}
ppc_stat_grouped(y = dataset1.bayesiant.y,
                 yrep = dataset1.bayesiant.yrep,
                 group = exp1.data$condition, binwidth = .1)
```

### Step 3: Comparing posterior distributions

Now that we have performed model diagnostics, we would like to interpret the results. The pertinent research question here is whether there is a difference in the effectiveness rating between the *graph* and *no graph* condition. We use conditional distributions to compare the mean difference between the two conditions. `add_epred_draws()` from the `tidybayes` package is the most convenient way.

```{r dataset1-t-test-posterior-fitted}
dataset1.bayesiant.posterior_epred <-
  tibble(condition = c('graph', 'no_graph')) %>%
  add_epred_draws(dataset1.brm.bayesiant,
                  re_formula = NA,
                  allow_new_levels = FALSE) %>%
  ungroup()

head(dataset1.bayesiant.posterior_epred)
```

Here `add_epred_draws()` takes two arguments:

-   *newdata*: is used to generate predictions. This variable should describe the experimental design. In this example, our experimental design consists of two conditions, *graph* and *no graph*, which is being passed as the first argument.

-   *object*: the model fit object

We then transform the data, subtract the two conditions from each other (using the `compare_levels()` function), and calculate the credible intervals (using `mean_qi()`).

```{r dataset1-bayesiant-posterior_comparison}
dataset1.bayesiant.posterior_comparison <-
  dataset1.bayesiant.posterior_epred %>%
  select(-c(.chain, .iteration, .row)) %>%
  compare_levels(variable = .epred, by = condition)

head(dataset1.bayesiant.posterior_comparison)

dataset1.bayesiant.posterior_comparison %>%
        mean_qi(.epred)
```

A basic way to interpret and communicate the results is to plot them. We plot this result using credible interval. In lecture 3, you will learn how to choose among these visualizations.

```{r dataset1.bayesiant.diff-1, fig.height=2, fig.width=5}
p3 = dataset1.bayesiant.posterior_epred %>%
  ggplot(aes(x = .epred, fill = condition)) +
  #geom_point(aes(x = .epred, group = condition), color = DARK_PURPLE, size = 3) +
  geom_density(
    #fill = DARK_PURPLE,
    color = NA,
    alpha = .5,
    #geom = 'dots',
    #size = 1,
    #height = 0
  ) +
  scale_fill_manual(values = COLOR_PALETTE) + 
  #geom_vline(aes(xintercept = 0), linetype = "dashed", color = "black") +
  #coord_cartesian(xlim = c(-1, 1))  +
  xlab('')

p3
```

```{r dataset1.bayesiant.diff-2, fig.height=2, fig.width=5}
dataset1.bayesiant.posterior_comparison %>%
  ggplot(aes(x = .epred)) +
  #geom_point(aes(x = .epred, group = condition), color = DARK_PURPLE, size = 3) +
  geom_density(
    fill = DARK_PURPLE,
    color = NA,
    alpha = .5,
    #geom = 'dots',
    #size = 1,
    #height = 0
  ) +
  geom_vline(aes(xintercept = 0), linetype = "dashed", color = "black") +
  coord_cartesian(xlim = c(-1, 1))  +
  ggtitle('no_graph - graph') + 
  xlab('difference in mean')
```

```{r dataset1.bayesiant.diffci, fig.height=2, fig.width=5}
dataset1.bayesiant.posterior_comparison %>%
  median_qi(.epred) %>%
  ggplot() +
  geom_point(aes(x = .epred, y = condition), color = DARK_PURPLE, size = 3) +
  geom_errorbarh(
    aes(xmin = .lower, xmax = .upper, y = condition),
    color = DARK_PURPLE,
    alpha = .5,
    size = 2,
    height = 0
  ) +
  geom_vline(aes(xintercept = 0), linetype = "dashed", color = "black") +
  coord_cartesian(ylim = c(0, 2), xlim = c(-1, 1))  +
  xlab('') + ylab('')
```

```{r}
dataset1.bayesiant.posterior_comparison %>%
  mutate(if_greater = .epred < 0) %>%
  summarise(`Pr(graph > no_graph)` = mean(if_greater))
```

Finally, we compare the results obtained from the Bayesian model to the frequentist estimates:

```{r dataset1-t-test-compare, fig.height=4, fig.width=10, warning=FALSE}
bind_rows(tidy.wrapper(dataset1.lm.freqt),
          tidy.wrapper(dataset1.brm.bayesiant)) %>%
  ggplot() +
  geom_pointrange(
    aes(
      color = model,
      y = estimate,
      ymin = conf.low,
      ymax = conf.high,
      x = term
    ),
    position = position_dodge(width = 0.2)
  ) +
  scale_color_brewer(palette = "Set1") +
  ylab('effectiveness') +
  scale_y_continuous(breaks = 1:9, limits = c(1, 9)) +
  coord_flip()
```

## Model 3. Ordinal Logistic Regression

A more appropriate to analyze ordinal data is to use ordinal logistic regression. In this section, we reanalyze the data using Bayesian ordinal logistic regression.

### Step 1: Build the model (likelihood)

As always the first step is to specify the appropriate model formula:

```{r bayesian-ordinal-logistic-regression-formula}
dataset1.brm.olr.formula <-
  bf(effectiveness ~ condition,
     family = cumulative("logit"))
```

Before we go further into the model building step, it is important to understand what a ordinal regression model is *estimating*. The figure below shows the cumulative proportion of participants who responded at least $k$, i.e. $Pr(y_i \leq k)$, on a Likert-style question.

```{r ordinal-logistic-regression-cumulative-proportion, fig.height=4, fig.width=8}
# figure from: Statistical rethinking with brms, ggplot2, and the tidyverse: Second edition by A Solomon Kurz
p1 = exp1.data %>%
  count(effectiveness) %>%
  mutate(pr_k = n / nrow(exp1.data),
         cum_pr_k = cumsum(pr_k)) %>%
  ggplot(aes(x = effectiveness, y = cum_pr_k,
             fill = effectiveness)) +
  geom_line(color = "#b8925f") +
  geom_point(colour = "#b8925f",
             size = 2.5,
             stroke = 1) +
  scale_x_continuous("Effectiveness", breaks = 1:9) +
  scale_y_continuous("Cumulative Proportion",
                     breaks = seq(0, 1, by = 0.2),
                     limits = c(0, 1)) +
  theme(axis.ticks = element_blank(),
        legend.position = "none")

p2 = exp1.data %>%
  count(effectiveness) %>%
  mutate(pr_k = n / nrow(exp1.data),
         log_cum_odds = logit(cumsum(pr_k))) %>%
  ggplot(aes(x = effectiveness, y = log_cum_odds,
             fill = effectiveness)) +
  geom_line(color = "#b8925f") +
  geom_point(colour = "#b8925f",
             size = 2.5,
             stroke = 1) +
  scale_x_continuous("Effectiveness", breaks = 1:9) +
  scale_y_continuous(
    "Log-Cumulative Odds",
    breaks = seq(-5, 5, by = 1),
    limits = c(logit(0.005), logit(0.99))
  ) +
  theme(axis.ticks = element_blank(),
        legend.position = "none")

ggarrange(p1, p2)
```

Since cumulative proportion is a value bounded between 0 and 1, linear regression models apply the logit function to apply the following transformation $f: [0, 1] \to (-Inf, Inf)$. Applying this transformation to the data gives the plot on the right.

Ordinal regression estimates this cumulative probability: $Pr(y_i \leq k)$. They do this using a series of parameters $\alpha_k$ where $k \in \{1, 2, 3, 4, 5, 6, 7, 8, 9\}$, according to the following equation:

$$
\begin{align}
log(\frac{Pr(y_i <= k)}{1 - Pr(y_i <= k)}) = \alpha_k
\end{align}
$$ Ordinal regression estimates this cumulative probability: $Pr(y_i \leq k)$. Once we have estimated the cumulative probability, we can take the difference between successive items, $Pr(y_i = k) = Pr(y_i \leq k) - Pr(y_i \leq k - 1)$, to estimate the discrete probability for each outcome:

```{r ordinal-logistic-regression-cumulative-proportion-diff}
# primary data
exp1.data_plot = exp1.data %>%
  count(effectiveness) %>%
  mutate(pr_k = n / nrow(exp1.data)) %>%
  add_row(effectiveness = 2, n = 0, pr_k = 0) %>%
  arrange(effectiveness) %>%
  mutate(cum_pr_k = cumsum(n / nrow(exp1.data))) %>% 
  mutate(discrete_probability = ifelse(effectiveness == 1, cum_pr_k, cum_pr_k - pr_k))

text = exp1.data_plot %>%
  mutate(
    text = effectiveness,
    effectiveness = effectiveness + 0.25,
    cum_pr_k = ifelse(cum_pr_k - 0.05 < 0.065, 0.05, cum_pr_k - 0.05)
  )

exp1.data_plot %>% 
  ggplot(aes(x = effectiveness, y = cum_pr_k)) +
  geom_line(aes(color = cum_pr_k), color = "#b8925f") +
  geom_linerange(aes(ymin = 0, ymax = cum_pr_k), alpha = 1/2, color = "#b8925f") +
  geom_linerange(aes(x = effectiveness,
                     ymin = ifelse(effectiveness == 1, 0, discrete_probability), 
                     ymax = cum_pr_k),
                 color = "black") +
  geom_point(colour = "#b8925f", size = 2.5, stroke = 1) +
  # number annotation
  geom_text(data = text, 
            aes(label = text),
            size = 4) +
  scale_x_continuous("Effectiveness", breaks = 1:9) +
  scale_y_continuous("Cumulative Proportion", breaks = seq(0, 1, by = 0.2), limits = c(0, 1)) +
  theme(axis.ticks = element_blank(),
        axis.title.y = element_text(angle = 90),
        legend.position = "none")
```

### Step 1: Build the model (priors)

The next step is to specify the prior distributions. Let us first look at the default prior distributions:

```{r dataset1-olr-priors}
as_tibble(get_prior(dataset1.brm.olr.formula, data = exp1.data))
```

We notice that the difference parameter, `b` does not have a proper prior, so we should specify one. The Intercept term does have a prior, but since the distributions are going to be logit-transformed it is difficult to intuitively determine whether these are strong or diffuse prior distributions. This is another important question that can be answered through prior predictive checks:

```{r dataset1-olr-priorchecks}
# priors
dataset1.brm.olr.priors = c(
      	  prior(normal(0, 1), class = "b")
)

dataset1.brm.olr.priorchecks <- brm(
    dataset1.brm.olr.formula,
    data = exp1.data,
    prior = dataset1.brm.olr.priors,
    iter = 15000,
    warmup = 7500,
    backend = BRM_BACKEND,
    sample_prior = 'only',
    file = "rds/dataset1.brm.bayesiant.priorchecks1.rds"
  )

dataset1.olr.yprior <-  posterior_predict(dataset1.brm.olr.priorchecks, ndraws = 100)

ggplot() +
  geom_histogram(aes(x = dataset1.olr.yprior),
               fill = DARK_PURPLE,
               alpha = .5, size = 1,
               binwidth = 0.5, center = 0) +
 scale_x_continuous(breaks = 1:9, limits = c(0.5, 9.5)) + 
 labs(x = 'Prior predictive distribution',  y = "") +
 theme(
   axis.text.y = element_blank()
 )
```

Our prior predictive check reveals that the model is assigning most of the probability mass to middle answer (5). This is not necessarily a bad thing, and it might reflect how participants behave. However, it is possible that these priors are still diffuse, as noticed by the low number of `Bulk_ESS` and `Tail_ESS`. These may act as another diagnostic measure, and ideally you'd want these values to be at least greater than 1000. Let's us try a different prior

```{r bayesian-ordinal-logistic-regression-prior-checks-1, fig.height=4, fig.width=8}
dataset1.brm.olr.priors = c(prior(normal(0, 1), class = "b"),
                            prior(student_t(3, 0, 1.5), class = "Intercept"))

dataset1.brm.olr.priorchecks <- brm(
    dataset1.brm.olr.formula,
    prior = dataset1.brm.olr.priors,
    data = exp1.data,
    iter = 15000,
    warmup = 7500,
    backend = BRM_BACKEND,
    sample_prior = 'only',
    file = "rds/dataset1.brm.bayesiant.priorchecks2.rds"
    )

summary(dataset1.brm.olr.priorchecks)
```

Changing the priors appear to improve `Bulk_ESS` and `Tail_ESS` slightly. Let's take a look at the prior predictive distribution:

```{r bayesian-ordinal-logistic-regression-prior-checks-2, fig.height=4, fig.width=8}
dataset1.olr.yprior <-
  posterior_predict(dataset1.brm.olr.priorchecks, ndraws = 100)


ggplot() +
  geom_histogram(aes(x = dataset1.olr.yprior),
               fill = '#351c75',
               alpha = .5,
               size = 1,
               binwidth = .5) +
  scale_x_continuous(breaks = 1:9, limits = c(0.5, 9.5)) + 
  xlab('prior draws') + ylab('')
```

For now, let us proceed with these priors.

### Step 2: Computing the posterior probability

After we've completed the model building phase, we can then compile the model.

```{r bayesian-ordinal-logistic-regression-run-1}
dataset1.brm.olr1 =
  brm(
    dataset1.brm.olr.formula,
    prior = dataset1.brm.olr.priors,
    data = exp1.data,
    backend = BRM_BACKEND,
    file = "rds/dataset1.brm.olr1.rds"
  )

summary(dataset1.brm.olr1)
```

Notice that we get a few error messages about divergent transitions. Here we adjust a few sampling parameters, namely `adapt_delta` and `max_treedepth` which are passed to the `control` argument, to help the MCMC sampler and avoid divergent transitions:

```{r bayesian-ordinal-logistic-regression-run-2}
dataset1.brm.olr2 =
  brm(
    dataset1.brm.olr.formula,
    prior = dataset1.brm.olr.priors,
    data = exp1.data,
    backend = BRM_BACKEND,
    warmup = 1500,
    iter = 2500,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    file = "rds/dataset1.brm.olr2.rds"
  )

summary(dataset1.brm.olr2)
```

### Step 3: Evaluate the fit

We then perform the same model diagnostics steps that we had performed for the previous model.

```{r dataset1-brm-olr-mcmc}
plot(dataset1.brm.olr2, newpage = T, ask=FALSE)
```

### Step 3: Evaluate the posterior predictions

```{r dataset1-olr-posterior-checks, fig.height=3, fig.width=10}
dataset1.olr.y <- exp1.data$effectiveness
dataset1.olr.yrep <- posterior_predict(dataset1.brm.olr2)

ppc_hist(y = dataset1.olr.y,
         yrep = dataset1.olr.yrep[1000:1007, ],
         binwidth = .5)

ppc_dens_overlay(y = dataset1.olr.y,
                 yrep = dataset1.olr.yrep[2000:2050, ], adjust = .5)


ppc_bars(y = dataset1.olr.y,
        yrep = dataset1.olr.yrep, binwidth = .5)


ppc_stat_grouped(y = dataset1.olr.y,
                 yrep = dataset1.olr.yrep,
                 group = exp1.data$condition)

```

### Step 3: Compare posterior distributions

Finally we estimate the difference between the two conditions and plot the results:

```{r dataset1-olr-epred-draws}
dataset1.olr.posterior_epred <-
  tibble(condition = c('graph', 'no_graph')) %>%
  add_epred_draws(dataset1.brm.olr2,
                  re_formula = NA,
                  allow_new_levels = FALSE) %>%
  ungroup()

head(dataset1.olr.posterior_epred)
```

```{r dataset1-olr-epred-draws-explanation, fig.height=4, fig.width=9}

dataset1.olr.posterior_epred  %>% 
  filter(.draw == 100) %>%
  group_by(condition) %>%
  rename(`probability` = .epred) %>%
  ggplot(., aes(x = .category, y = `probability`, fill = condition, color = condition)) + 
  geom_bar(stat = 'identity', alpha = .5, color = NA, width = .3) + 
  geom_point(aes(group = condition)) + 
  geom_path(aes(group = condition)) + 
  facet_wrap(condition ~ ., ncol = 2) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, .2)) + 
  scale_color_manual(values = c(DARK_PURPLE, GOLD_COLOR)) + 
  scale_fill_manual(values = c(DARK_PURPLE, GOLD_COLOR)) +
  xlab('')


dataset1.olr.posterior_epred %>% 
  select(-.chain, -.iteration, -.row) %>%
  group_by(condition, .draw, .category) %>%
  rename(probability = .epred) %>%
  ungroup() %>%
  group_by(.category, condition) %>%
  median_qi(probability) %>%
ggplot(., aes(x = .category, y = probability, fill = condition, color = condition)) + 
  geom_bar(stat = 'identity', alpha = .5, color = NA, width = .3) + 
  geom_errorbar(aes(ymin = .lower, ymax = .upper), width = 0, size = 1) + 
  geom_point(aes(group = condition)) + 
  geom_path(aes(group = condition)) + 
  facet_wrap(condition ~ ., ncol = 2) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, .2)) + 
  scale_color_manual(values = c(DARK_PURPLE, GOLD_COLOR)) + 
  scale_fill_manual(values = c(DARK_PURPLE, GOLD_COLOR))  +
  xlab('')


dataset1.olr.posterior_epred  %>% 
  filter(.draw == 100) %>%
  #arrange(.category) %>%
  group_by(condition) %>%
  mutate(`cumulative probability` = cumsum(.epred)) %>%
  ggplot(., aes(x = .category, y = `cumulative probability`, fill = condition, color = condition)) + 
  geom_bar(stat = 'identity', alpha = .5, color = NA, width = .3) + 
  geom_point(aes(group = condition)) + 
  geom_path(aes(group = condition)) + 
  facet_wrap(condition ~ ., ncol = 2) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, .2)) + 
  scale_color_manual(values = c(DARK_PURPLE, GOLD_COLOR)) + 
  scale_fill_manual(values = c(DARK_PURPLE, GOLD_COLOR))  +
  xlab('')


dataset1.olr.posterior_epred %>% 
  select(-.chain, -.iteration, -.row) %>%
  group_by(condition, .draw) %>%
  arrange(.category) %>%
  mutate(`cumulative probability` = cumsum(.epred)) %>%
  ungroup() %>%
  group_by(.category, condition) %>%
  median_qi(`cumulative probability`) %>%
ggplot(., aes(x = .category, y = `cumulative probability`, fill = condition, color = condition)) + 
  geom_bar(stat = 'identity', alpha = .5, color = NA, width = .3) + 
  geom_errorbar(aes(ymin = .lower, ymax = .upper), width = 0, size = 2) + 
  geom_point(aes(group = condition)) + 
  geom_path(aes(group = condition), size = 1) + 
  facet_wrap(condition ~ ., ncol = 2) +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, .2)) + 
  scale_color_manual(values = c(DARK_PURPLE, GOLD_COLOR)) + 
  scale_fill_manual(values = c(DARK_PURPLE, GOLD_COLOR))  +
  xlab('')
```

```{r dataset1-olr-comparison-1}
dataset1.olr.posterior_comparison <-
  dataset1.olr.posterior_epred %>%
  select(-c(.chain, .iteration, .row)) %>%
  group_by(.category) %>%
  compare_levels(variable = .epred, by = condition)

head(dataset1.olr.posterior_comparison %>%
       mean_qi())
```

```{r dataset1-olr-comparison-2, fig.height=3, fig.width=10}
dataset1.olr.posterior_comparison %>%
  mean_qi(.epred) %>%
  ggplot() +
  geom_point(aes(y = .epred, x = .category), size = 3, color = DARK_PURPLE) +
  geom_errorbar(
    aes(ymin = .lower, ymax = .upper, x = .category),
    width = 0,
    size = 2,
    color = DARK_PURPLE,
    alpha = .5
  ) +
  coord_cartesian(ylim = c(-.1, .1)) + 
  geom_hline(aes(yintercept = 0), linetype = "dashed", color = "gray") +
  xlab('') + ylab('no_graph - graph') +
  theme(axis.title.y = element_text(angle = 0, vjust = .5))
```

# Dataset 2

The following dataset is from experiment 2 of "How Relevant are Incidental Power Poses for HCI?" [(Jansen & Hornbæk, 2018)](https://doi.org/10.1145/3173574.3173588).
Study participants were asked to either make an expansive posture or a constrictive posture before performing a task. The experiment is a between-subjects design. The dependent variable is the percentage change in risk-taking behavior. Therefore, it is a variable on an interval scale (continuous).

First, we load the data.

```{r load-dataset-2}
dataset2 = readr::read_csv("data/exp2.csv", show_col_types = FALSE) %>%
  mutate(condition = condition == 'expansive') %>%
  group_by(participant)

head(dataset2)
```

We plot the data to give us a better picture about its distribution.

```{r dataset2, fig.height=3, fig.width=7}
dataset2 %>%
  mutate(c = as.factor(condition)) %>%
  ggplot(aes(x = change)) +
  geom_histogram(
    aes(y = ..density..),
    binwidth = 10,
    fill = DARK_PURPLE,
    alpha = .5,
    color = 'white'
  ) +
  geom_density(size = 1,
               adjust = 1.5,
               color = '#9281bf') +
   geom_function(
    color = "#222222",
    linetype = 'dashed',
    fun = function(x)
      dstudent_t(x, mu = 16,  sigma = 39, df = 6),
    size = 1
  ) + 
  scale_x_continuous(limits = c(-200, 200)) 
```

### Step 1: Build the model (likelihood and priors)

This model is the BEST test model as described by Kruschke in the paper *Bayesian estimation supersedes the t-test*. In this model, $\beta$ indicates the mean difference in the outcome variable between the two groups (in this case, the percent change in the BART scores). We fit different priors on $\beta$ and set different weights on these priors to obtain our posterior estimate.

$$
\begin{align}
y_{i} &\sim \mathrm{T}(\nu, \mu, \sigma) \\
\mu &= \alpha_{0} + \beta * x_i \\
\sigma &= \sigma_{a} + \sigma_{b}*x_i \\
\beta &\sim \mathrm{N}(\mu_{0}, \sigma_{0}) \\
\sigma_a, \sigma_b &\sim \mathrm{Cauchy}(0, 2) \\
\nu &\sim \mathrm{exp}(1/30)
\end{align}
$$

We translate the above specification to R code.

```{r dataset2-model1-formula}
dataset2.brm.student.formula <- bf(change ~ condition,
                                   sigma ~ condition,
                                   family = student())

head(as_tibble(get_prior(dataset2.brm.student.formula, data = dataset2)))
```

```{r dataset2-bayesiant-prior-checkes}
# This breaks :-)
dataset2.brm.student.priorchecks = brm(
  dataset2.brm.student.formula,
  prior = c(
    prior(normal(0, 2), class = "b"),
    prior(cauchy(0, 2), class = "b", dpar = "sigma"),
    prior(exponential(0.033), class = "nu"),
    prior(student_t(3, 0, 5), class = "Intercept"),
    prior(student_t(3, 0, 1), class = "Intercept", dpar = "sigma")
  ),
  data = dataset2,
  backend = BRM_BACKEND,
  sample_prior = 'only',
  file = "rds/dataset2.brm.student.priorchecks.rds"
)
```

```{r}
min(dataset2$change)
max(dataset2$change)
dataset2.yprior <-  posterior_predict(dataset2.brm.student.priorchecks)

ggplot() +
  geom_histogram(aes(x = dataset2.yprior),
               fill = DARK_PURPLE,
               alpha = .5, 
               size = 1, 
               center = 0) +
 #scale_x_log10() + 
 # scale_x_continuous(breaks = 1:9, limits = c(0.5, 9.5)) + 
 labs(x = 'Prior predictive distribution',  y = "") +
 theme(
   axis.text.y = element_blank()
 )

dim(dataset2.yprior) <- 4000 * 80

quantile(dataset2.yprior, probs = c(.025, .975))

```

### Step 2: Computing the posterior probability

```{r dataset2-bayesiant}
dataset2.brm.student = brm(
 bf(change ~ condition, 
 sigma ~ condition,
 family = student()),
 prior = c(
   prior(normal(0, 2), class = "b"),
   prior(cauchy(0, 2), class = "b", dpar = "sigma"),
   prior(exponential(.033), class = "nu"),
   prior(student_t(3, 0, 5), class = "Intercept"),
   prior(student_t(3, 0, 2), class = "Intercept", dpar = "sigma")
 ), 
 data = dataset2,
 backend = BRM_BACKEND,
 file = "rds/dataset2.brm.student.rds"
)

dataset2.brm.student$prior
```

### Step 3: Evaluate the fit (summary)

```{r dataset2-brm-student-summary}
summary(dataset2.brm.student)
```

### Step 3: Evaluate the posterior predictions

```{r dataset2-diagnotics-1, fig.height=8, fig.width=10}
plot(dataset2.brm.student, newpage = T)
```

```{r dataset2-posterior-diagnotics-2}

dataset2.student.y <- dataset2.brm.student$data$change
dataset2.student.yrep <- posterior_predict(dataset2.brm.student)

dataset2.student.epred <- tibble(condition = c(TRUE, FALSE)) %>%
  add_epred_draws(dataset2.brm.student,
                  re_formula = NA,
                  allow_new_levels = TRUE) %>%
  ungroup()
```

```{r dataset2-posterior-diagnotics-3, fig.height=3, fig.width=10}
ppc_hist(y = dataset2.student.y,
         yrep = dataset2.student.yrep[100:107, ],
         binwidth = 10)


ppc_dens_overlay(y = dataset2.student.y,
                 yrep = dataset2.student.yrep[2000:2030, ])


ppc_stat_grouped(
  y = dataset2.student.y,
  yrep = dataset2.student.yrep,
  group = dataset2$condition,
  binwidth = 5
)
```

### Step 3: Compare the posterior predictions

```{r dataset2-student-posterior-fitted}

dataset2.student.epred_comparison <-
  tibble(condition = c(TRUE, FALSE)) %>%
  add_epred_draws(dataset2.brm.student,
                  re_formula = NA,
                  allow_new_levels = FALSE) %>%
  ungroup() %>%
  select(-c(.chain, .iteration, .row)) %>%
  compare_levels(variable = .epred, by = condition) %>%
  rename(diff = .epred)


head(dataset2.student.epred_comparison)


```

```{r dataset2.studenyt.diffci, fig.height=1, fig.width=5}
dataset2.student.epred_comparison %>%
  select(diff) %>%
  mean_qi() %>%
  ggplot() +
  geom_point(aes(x = diff, y = condition), size = 3, color = DARK_PURPLE) +
  geom_errorbarh(
    aes(xmin = .lower, xmax = .upper, y = condition),
    height = 0,
    color = DARK_PURPLE,
    alpha = .5,
    size = 2
  ) +
  geom_vline(aes(xintercept = 0), linetype = "dashed", color = "gray") +
  coord_cartesian(ylim = c(0, 2), xlim = c(-5, 5))  +
  scale_y_discrete(label = c('expansive - not expansive')) +
  xlab('')  + ylab('')
```

## Compare variance

```{r dataset2-student-posterior-fitted-sigma}

dataset2.student.sigma.epred_comparison <-
  tibble(condition = c(TRUE, FALSE)) %>%
  add_epred_draws(dataset2.brm.student,
                  dpar = "sigma",
                  re_formula = NA,
                  allow_new_levels = FALSE) %>%
  ungroup() %>%
  select(-c(.chain, .iteration, .row)) %>%
  compare_levels(variable = sigma, by = condition) %>%
  rename(sigma.diff = sigma)


head(dataset2.student.sigma.epred_comparison)


```

```{r dataset2.studenyt.diff--sigma, fig.height=1, fig.width=5}
dataset2.student.sigma.epred_comparison %>%
  select(sigma.diff) %>%
  mean_qi() %>%
  ggplot() +
  geom_point(aes(x = sigma.diff, y = condition), size = 3, color = DARK_PURPLE) +
  geom_errorbarh(
    aes(xmin = .lower, xmax = .upper, y = condition),
    height = 0,
    color = DARK_PURPLE,
    alpha = .5,
    size = 2
  ) +
  geom_vline(aes(xintercept = 0), linetype = "dashed", color = "gray") +
  coord_cartesian(ylim = c(0, 2), xlim = c(-15, 15))  +
  scale_y_discrete(label = c('expansive - not expansive')) +
  xlab('')  + ylab('')
```

# Packages Information

```{r}

sessionInfo()

```
